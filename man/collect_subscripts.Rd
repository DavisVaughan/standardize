% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collect-subscripts.R
\name{collect_subscripts}
\alias{collect_subscripts}
\title{Standardize subscripts}
\usage{
collect_subscripts(
  i,
  j,
  ...,
  column_transform = TRUE,
  env = parent.frame(),
  fn = sys.function(sys.parent())
)
}
\arguments{
\item{i, j}{\verb{[vector]}

Required vectors of subscripts.}

\item{...}{\verb{[dots]}

Optional additional subscripts for subsetting into higher dimensions. Names
are preserved. Implicit missing subscripts are transformed into explicit
\code{NULL} values.

If no \code{...} are provided, the return value will contain an empty list
in the \verb{$dots} slot.}

\item{column_transform}{\verb{[logical(1)]}

Should a single \code{i} argument represent column subsetting? For example,
this standardizes \code{x[i]} to \code{x[,j]}. This is useful when creating data
frame \code{[} methods, but array subsetting likely won't use this feature.}

\item{env}{\verb{[environment]}

Generally, the calling environment of the \code{[} method. Used to detect
the number of arguments supplied when the user invoked the \code{[} method.}

\item{fn}{\verb{[function]}

Generally, the function corresponding to the \code{[} method. Used to check
that the \code{[} method is valid, and to count the number of arguments
alongside \code{env}.}
}
\value{
A named list of the following 4 elements containing information about the
standardized subscripts.
\itemize{
\item \code{i}: The standardized \code{i} subscript. If \code{NULL}, \code{i} is considered to be
missing.
\item \code{j}: The standardized \code{j} subscript. If \code{NULL}, \code{j} is considered to be
missing.
\item \code{dots}: A list of the standardized \code{...} subscripts. If no \code{...} are
supplied, an empty list is returned. If \code{...} are supplied and any
subscripts are missing, \code{NULL} values are returned in those locations.
For example, \code{x[i, j, , k]} would return a list of \code{list(NULL, k)}.
\item \code{transformed}: A logical of size 1 indicating whether the transformation
of \code{x[i]} to \code{x[,j]} was performed or not.
}
}
\description{
\code{collect_subscripts()} standardizes subscripts to make it easier to
develop \code{[} methods, especially for data frame and array subsetting.
It helps with a number of things, including:
\itemize{
\item Counting the number of subscript arguments supplied.
\item Transforming implicit missing subscripts into explicit \code{NULL} values.
\item Optional support for capturing \code{...}.
\item Optional support for standardizing the data frame column subsetting
behavior of \code{x[i]} into \code{x[,j]}.
}

\code{collect_subscripts()} can \strong{only} be called from inside of a function.
Calling \code{collect_subscripts()} in the console directly will result in
an error.

The expected way to use \code{collect_subscripts()} is as the first line of
a \code{[} method. You'll collect the processed subscripts, and then use
them to slice the input accordingly.
}
\details{
If \code{NULL} is provided as a subscript, it is standardized to \code{integer()} to
prevent confusion with \code{NULL} values in the resulting info list. A \code{NULL}
subscript should have the same meaning as \code{integer()}.
}
\examples{
# Generally you would replace `slicer()` with your `[.myclass` method,
# which you would then call as `x[i]`. This just collects the subscript info
# and returns a compact view of it. Normally you would use the processed
# results to slice `x`.

slicer <- function(x, i, j, ..., drop = FALSE) {
  info <- collect_subscripts(i, j, ...)
  str(info)
}

x <- "a"

# Standardize an easy case
slicer(x, 1:5, 2)

# By default, supplying just `i` standardizes `x[i]` to `x[,j]`
slicer(x, 1)

# With just `j`, the implicit missing `i` value is returned as a `NULL`.
slicer(x, , 1)

# This would be equivalent to calling `x[]`
slicer(x, )

# Extra `...` are standardized too. Again, implicit dimensions are returned
# as `NULL`.
slicer(x, 1, 2, 3)
slicer(x, 1, 2, , 3)


# You don't have to supply `...` if you don't need it. This
# won't be as useful because it isn't as complex to count here, but it
# will still standardize `x[i]`, which is nice.
slicer_simple <- function(x, i, j) {
  collect_subscripts(i, j)
}

slicer_simple(x, 1)
}
